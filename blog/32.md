---
title: 备忘录
date: 2017-05-25 16:39:45
tags:
- 工作效率
---

js serialize 序列化（表单转字符串）

post 请求

``` js
function(){
    var xhr = CreateXHR();
    xhr.onreadystatechange = function(){
        if(xhr.readyState == 4){//检测XHR的readyState属性
            if((xhr.status >= 200 && xhr.status <= 300) || xhr.status == 304){
                alert(xhr.responseText);
            }else{
                alert("Request was unsuccessful:" + xhr.status);
            }
        }
    };
    
    xhr.open("post","post.php",true);
    xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
    var form = document.getElementById("ID");
    xhr.send(serialize(form));
}
```

get和post区别
1.get用于信息获取，post用于修改服务器上的资源
2.get数据附在url后，post放在http报文实体的主体中
3.get数据量限制在2kb ，由于浏览器对url有限制，ie为2kb，chrome、firefox理论上没有限制，真正限制取决于操作系统，post对数据没有限制，取决于服务器端处理程序的能力

``` js
if (true) {
  // TDZ开始
  tmp = 'abc'; // ReferenceError
  console.log(tmp); // ReferenceError
  let tmp; // TDZ结束
  console.log(tmp); // undefined
  tmp = 123;
  console.log(tmp); // 123
}
```
上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。

“暂时性死区”也意味着typeof不再是一个百分之百安全的操作。

所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。

```
function bar(x = y, y = 2) {
  return [x, y];
}
bar(); // 报错
function bar(y=2,x = y) {
  return [x, y];
}
bar(); //[2,2]
```