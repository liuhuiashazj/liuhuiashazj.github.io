---
title: 纪要
date: 2017-10-26
tags: 
- input
- umd
---

## input与change区别
input在每次输入时都会触发，change只有在输入完blur时触发
vue的input组件，v-modal提供了.lazy修饰符，这样就可以将默认的input同步数据转为change触发

##UMD/CommonJS/AMD/CMD


###### CommonJS, Node的编码规范
``` js
var $ = require('jquery');
function myFunc(){};
module.exports = myFunc;
```
CommonJS加载模块是同步的，所以只有加载完毕后才能执行后面的操作。Nodejs主要用于服务器端编程，加载的模块一般都已经存在本地硬盘，加载加快，所以不用考虑异步加载的方式

###### AMD(Asynchronous Module Definition)
RequireJS遵循AMD规范，他的作者是AMD规范的创始人。
AMD设计出一个简洁的写模块API：
define(id?, dependencies?, factory);
``` js
define(["alpha"], function( alpha ){
    return {
        verb : function(){
            return alpha.verb() + 1 ;
        }
    }
});
```

###### CMD是SeaJS推广过程中对模块定义的规范化产出
CMD推崇依赖就近，AMD推崇依赖前置,RequireJS从2.0开始，也改为可以延迟执行
``` js
//AMD
define(['./a','./b'], function (a, b) {
    //依赖一开始就写好
    a.test();
    b.test();
});
 
//CMD
define(function (requie, exports, module) {
    //依赖可以就近书写
    var a = require('./a');
    a.test();
    ...
    //软依赖
    if (status) {
        var b = requie('./b');
        b.test();
    }
});
```

###### UMD(Universal Module Definition) 通用模块规范
UMD是AMD和CommonJS的糅合
``` js
(function (root, factory) {
	if (typeof define === 'function' && define.amd) {
		// AMD
		define(['jquery'], factory);
	} else if (typeof exports === 'object') {
		// Node, CommonJS之类的
		module.exports = factory(require('jquery'));
	} else {
		// 浏览器全局变量(root 即 window)
		root.returnExports = factory(root.jQuery);
	}
}(this, function ($) {
	//    方法
	function myFunc(){};
	//    暴露公共方法
	return myFunc;
}));
```


## vue中使用何种编译模式
vue可以选择运行时编译，或者预编译，这两种情况的区别在于运行时一个需要编译器，一个不需要编译器，如果需要在客户端编译模板，则需要加上编译器，即完整版的构建
``` js
// 需要编译器
new Vue({
  template: '<div>{{ hi }}</div>'
})
// 不需要编译器
new Vue({
  render (h) {
    return h('div', this.hi)
  }
})
```
当使用vue-loader或vueify的时候，*.vue的文件内部的模板会在构建时预编译成javascript，这种叫做运行时构建。

因为运行时构建相比完整版减少了30%的体积，所以尽可能使用这个版本，如果仍然洗完使用完整版构建，需要在打包工具里配置一个别名

``` js
// webpack.config.js
module.exports = {
  // ...
  resolve: {
    alias: {
      'vue$': 'vue/dist/vue.esm.js' // 'vue/dist/vue.common.js' for webpack 1
    }
  }
}
```


- vue.common.js 
基于commonJS的完整构建，用于webpack-1
因为是完整构建, 所以可以使用template选项, 如:
``` js
import Vue from 'vue'
new Vue({
  template: `
    <div id="app">
      <h1>Basic</h1>
    </div>
  `
}).$mount('#app')
```
注意: 用 webpack-1 之类打包工具时, 使用该版本, 需要配置别名, 以 webpack 为例:
``` js
{
  resolve: {
    alias: {
      'vue$': 'vue/dist/vue.common.js'
    }
  }
}
```

- vue.esm.js 
基本同上，除了alias换下

- vue.js
属于: 基于 UMD 的完整构建
可以用于直接 CDN 引用
因为是完整构建, 所以可以使用template选项, 如:
``` html
<script src="https://unkpg.com/vue/dist/vue.js"></script>
<script>
new Vue({
  template: `
    <div id="app">
      <h1>Hi Vue</h1>
    </div>
  `
}).$mount('#app')
</script>
```


- vue.runtime.common.js
属于: 基于 CommonJS 的运行时构建
运行时构建不包含模板编译器，因此不支持template选项，只能用render选项
如果使用webpack预编译，那么.vue文件里面也可以写template
``` js
import Vue from 'vue'
new Vue({
  render: function(h){
    return h('h1', 'Hi Vue')
  }
}).$mount('#app')
```

- vue.runtime.esm.js
属于: 基于 ES Module 的运行时构建
运行时构建不包含模板编译器，因此不支持template选项，只能用render选项
如果使用webpack预编译，那么.vue文件里面也可以写template
代码基本同上，除了2行代码

vue.runtime.common.js
``` js
// vue.runtime.common.js
'use strict'; 
// ...
module.exports = Vue$3 

// vue.runtime.esm.js
export default Vue$3;
```

- vue.runtime.js
属于: 基于 UMD 的运行时构建
可以用于直接 CDN 引用
不包含编译器，所以不能使用template选项，只能用render函数
``` html
<script src="https://unkpg.com/vue/dist/vue.runtime.js"></script>
<script>
new Vue({
  render: function(h){
    return h('h1', 'Hi Vue')
  }
}).$mount('#app')
</script>
```

可以看到vue.esm.js和vue.js的区别在于
- vue.js封装了UMD规范
``` js
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.Vue = factory());
}(this, (function () { 'use strict';
// ...
})));
```
- vue.esm.js 采用ESM定义规范
``` js
// ...
export default Vue$3;
```

- vue.js中讲所有的node环境变量改为字面量，“process.env.NODE_ENV” 改为 "process.env.NODE_ENV"
