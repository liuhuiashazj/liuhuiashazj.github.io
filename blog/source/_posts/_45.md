---
title: ES8的async&&await
date: 2017/12/8
---
Eventloop

首先，下面这段代码的运行结果是什么
``` js
async function asyncFun2() {
    console.log('asyncFun2');
}
async function asyncFun1() {
    console.log('asyncFun1');
    await asyncFun2();
    console.log('asyncFun3');
}
console.log('script start');
setTimeout(function () {
    console.log('setTimeout');
}, 0);
asyncFun1();
new Promise(function (resolve) {
    console.log('promise0');
    resolve();
})
.then(function () {
    console.log('promise1');
})
.then(function () {
    console.log('promise2');
});
console.log('script end');

```

经过测试
node 8.7.0/node 7.6结果，应该是采用迭代器放到微任务里面去
``` js
/* 
script start
asyncFun1
asyncFun2
promise0
script end
asyncFun3
promise1
promise2
setTimeout
*/
```

原理大概如下
``` js
(async function () {
	var v1 = await new Promise(function (resolve, then) {
		setTimeout(function () {
			resolve('hello');
		}, 1500);
	});
	console.log(v1);

	var v2 = await new Promise(function (resolve, then) {
		setTimeout(function () {
			resolve('liuhui');
		}, 1500);
	});
	console.log(v2);
}());


yieldPromise(function*(){
    var v1=yield new Promise(function(resolve,reject){
        setTimeout(function(){
            resolve('Hello');
        },1500);
    });

    console.warn(v1);

    var v2=yield new Promise(function(resolve,reject){
        setTimeout(function(){
            resolve('World');
        },1500);
    });

    console.warn(v2);
});


function yieldPromise(generator){
    var iterator=generator();
    recursiveCore.call(iterator);
}

function recursiveCore(feedback){
    var iterator=this,
        result=iterator.next(feedback);

    if(result.done){
        return;
    }

    var promise=result.value;
    Promise.resolve(promise).then(function(v){
        recursiveCore.call(iterator,v);
    });
}

```

看一下babel的转换方法
``` js
async function asyncFun2() {
    console.log('asyncFun2');
}
async function asyncFun1(){
	console.log('asyncFun1');
  	await asyncFun2();
  	console.log('asyncFun3');
}

//转换后
let asyncFun2 = (() => {
  var _ref = _asyncToGenerator(function* () {
    console.log('asyncFun2');
  });

  return function asyncFun2() {
    return _ref.apply(this, arguments);
  };
})();

let asyncFun1 = (() => {
  var _ref2 = _asyncToGenerator(function* () {
    console.log('asyncFun1');
    yield asyncFun2();
    console.log('asyncFun3');
  });

  return function asyncFun1() {
    return _ref2.apply(this, arguments);
  };
})();

function _asyncToGenerator(fn) {
    return function() {
        var gen = fn.apply(this, arguments);
        return new Promise(function(resolve, reject) {
            function step(key, arg) {
                try {
                    var info = gen[key](arg);
                    var value = info.value;
                } catch (error) {
                    reject(error);
                    return;
                }
                if (info.done) {
                    resolve(value);
                } else {
                    return Promise.resolve(value).then(function(value) {
                        step("next", value);
                    }, function(err) {
                        step("throw", err);
                    });
                }
            }
            return step("next");
        }
        );
    }
    ;
}

```
